'use client';

import { useState, useEffect, useCallback } from 'react';
import { apiFetch } from '@/lib/api-client';
import { buildQueryString } from '@/lib/query-string';

// ── Types ─────────────────────────────────────────────────────────

export type FindingSeverity = 'info' | 'positive' | 'warning' | 'critical';
export type FindingCategory = 'anomaly' | 'trend' | 'opportunity' | 'risk' | 'benchmark' | 'correlation';
export type FindingStatus = 'unread' | 'read' | 'dismissed' | 'acted_on';

export interface AnalysisFinding {
  id: string;
  title: string;
  /** Detailed explanation of the finding (markdown) */
  summary: string;
  severity: FindingSeverity;
  category: FindingCategory;
  status: FindingStatus;
  /** The metric(s) involved in this finding */
  metricSlugs: string[];
  /** Dimension values that scope this finding (e.g., specific location) */
  dimensionContext: Record<string, string> | null;
  /** Quantified impact (e.g., revenue at risk, potential savings) */
  impactEstimate: FindingImpact | null;
  /** AI-suggested actions to take based on this finding */
  suggestedActions: string[];
  /** Data points supporting the finding */
  evidenceData: Record<string, unknown>[] | null;
  /** The lens that generated this finding */
  lensSlug: string | null;
  /** Whether this finding was generated by background analysis vs. on-demand */
  isProactive: boolean;
  createdAt: string;
  readAt: string | null;
  dismissedAt: string | null;
}

export interface FindingImpact {
  /** Estimated monetary impact in dollars */
  amountDollars: number | null;
  /** Percentage impact on the primary metric */
  percentageImpact: number | null;
  /** Time horizon for the impact (e.g., "monthly", "quarterly") */
  timeHorizon: string | null;
  /** Confidence level of the estimate (0-1) */
  confidence: number;
}

// ── useAnalysisFindings ───────────────────────────────────────────

interface UseAnalysisFindingsOptions {
  limit?: number;
  severity?: FindingSeverity;
  category?: FindingCategory;
  status?: FindingStatus;
  lensSlug?: string;
}

export function useAnalysisFindings(opts: UseAnalysisFindingsOptions = {}) {
  const [findings, setFindings] = useState<AnalysisFinding[]>([]);
  const [unreadCount, setUnreadCount] = useState(0);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchFindings = useCallback(async () => {
    setIsLoading(true);
    setError(null);
    try {
      const qs = buildQueryString({
        limit: opts.limit,
        severity: opts.severity,
        category: opts.category,
        status: opts.status,
        lensSlug: opts.lensSlug,
      });
      const res = await apiFetch<{
        data: AnalysisFinding[];
        meta: { unreadCount: number };
      }>(`/api/v1/semantic/findings${qs}`);
      setFindings(res.data);
      setUnreadCount(res.meta.unreadCount);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load findings');
    } finally {
      setIsLoading(false);
    }
  }, [opts.limit, opts.severity, opts.category, opts.status, opts.lensSlug]);

  useEffect(() => {
    fetchFindings();
  }, [fetchFindings]);

  const markRead = useCallback(async (findingId: string): Promise<void> => {
    try {
      await apiFetch(`/api/v1/semantic/findings/${findingId}/read`, {
        method: 'POST',
      });
      const now = new Date().toISOString();
      setFindings((prev) =>
        prev.map((f) =>
          f.id === findingId
            ? { ...f, status: 'read' as const, readAt: now }
            : f,
        ),
      );
      setUnreadCount((prev) => Math.max(0, prev - 1));
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to mark finding as read');
    }
  }, []);

  const dismiss = useCallback(async (findingId: string): Promise<void> => {
    try {
      await apiFetch(`/api/v1/semantic/findings/${findingId}/dismiss`, {
        method: 'POST',
      });
      const now = new Date().toISOString();
      setFindings((prev) => {
        const finding = prev.find((f) => f.id === findingId);
        const wasUnread = finding?.status === 'unread';
        const updated = prev.map((f) =>
          f.id === findingId
            ? { ...f, status: 'dismissed' as const, dismissedAt: now }
            : f,
        );
        if (wasUnread) {
          setUnreadCount((c) => Math.max(0, c - 1));
        }
        return updated;
      });
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to dismiss finding');
    }
  }, []);

  const markActedOn = useCallback(async (findingId: string): Promise<void> => {
    try {
      await apiFetch(`/api/v1/semantic/findings/${findingId}/acted`, {
        method: 'POST',
      });
      setFindings((prev) =>
        prev.map((f) =>
          f.id === findingId
            ? { ...f, status: 'acted_on' as const }
            : f,
        ),
      );
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to mark finding as acted on');
    }
  }, []);

  return {
    findings,
    unreadCount,
    isLoading,
    error,
    markRead,
    dismiss,
    markActedOn,
    refresh: fetchFindings,
  };
}
